<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hand Gesture Magic - Optimized</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #ui { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; z-index: 100; }
        button { background: rgba(0, 255, 204, 0.2); border: 1px solid #00ffcc; color: #00ffcc; padding: 10px 15px; border-radius: 5px; cursor: pointer; }
        button:active { background: #00ffcc; color: #000; }
        #video-input { transform: scaleX(-1); position: fixed; top: 10px; right: 10px; width: 100px; height: 75px; border-radius: 5px; opacity: 0.6; pointer-events: none; }
    </style>
</head>
<body>
    <div id="ui">
        <button onclick="changeShape(0)">Follow Finger</button>
        <button onclick="changeShape(1)">Heart</button>
        <button onclick="changeShape(2)">Saturn</button>
    </div>
    <video id="video-input" autoplay playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script id="vertexShader" type="x-shader/x-vertex">
        uniform float uTime;
        uniform vec3 uHandPos;
        uniform float uShapeType; // 0: Follow, 1: Heart, 2: Saturn
        attribute float aOffset;
        varying vec3 vColor;

        void main() {
            vec3 pos = position;
            vec3 target = uHandPos;

            if (uShapeType == 1.0) { // Heart Logic
                float t = aOffset * 6.28;
                target += vec3(
                    1.6 * pow(sin(t), 3.0),
                    1.3 * cos(t) - 0.5 * cos(2.0*t) - 0.2 * cos(3.0*t) - 0.1 * cos(4.0*t),
                    sin(t) * 0.5
                ) * 2.0;
            } 
            else if (uShapeType == 2.0) { // Saturn Logic
                float t = aOffset * 6.28;
                if(mod(aOffset * 100.0, 2.0) > 1.0) { // Ring
                    target += vec3(cos(t) * 4.0, sin(t) * 0.5, sin(t) * 4.0);
                } else { // Planet
                    target += vec3(cos(t) * 1.5, sin(t) * 1.5, cos(aOffset * 3.14) * 1.5);
                }
            }

            // GPU Attraction: Particles move toward target instantly
            vec3 newPos = mix(pos, target, 0.1); 
            
            vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);
            gl_PointSize = (20.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
            vColor = vec3(0.0, 1.0, 0.8);
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        varying vec3 vColor;
        void main() {
            if (length(gl_PointCoord - vec2(0.5)) > 0.5) discard;
            gl_FragColor = vec4(vColor, 1.0);
        }
    </script>

    <script>
        const videoElement = document.getElementById('video-input');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        camera.position.z = 10;

        // Create Particles with Custom Shaders
        const count = 10000;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(count * 3);
        const offsets = new Float32Array(count);
        for(let i=0; i<count; i++) {
            positions[i*3] = (Math.random()-0.5)*20;
            positions[i*3+1] = (Math.random()-0.5)*20;
            positions[i*3+2] = (Math.random()-0.5)*20;
            offsets[i] = Math.random();
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('aOffset', new THREE.BufferAttribute(offsets, 1));

        const shaderMat = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uHandPos: { value: new THREE.Vector3(0,0,0) },
                uShapeType: { value: 0.0 }
            },
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent,
            transparent: true,
            blending: THREE.AdditiveBlending
        });

        const points = new THREE.Points(geometry, shaderMat);
        scene.add(points);

        function changeShape(type) {
            shaderMat.uniforms.uShapeType.value = type;
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5 });

        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks[0]) {
                const landmark = results.multiHandLandmarks[0][8];
                // Smoothly update hand position
                shaderMat.uniforms.uHandPos.value.lerp(new THREE.Vector3(
                    (landmark.x - 0.5) * -15, 
                    -(landmark.y - 0.5) * 15, 
                    0
                ), 0.2);
            }
        });

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 480, height: 360
        });
        cameraFeed.start();

        function animate() {
            requestAnimationFrame(animate);
            shaderMat.uniforms.uTime.value += 0.05;
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>